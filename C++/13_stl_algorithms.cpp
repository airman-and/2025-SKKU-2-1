#include <iostream>
#include <vector>
#include <algorithm> // Required for STL algorithms
#include <numeric>   // Required for std::iota and std::accumulate
#include <string>

// Helper function to print vector elements
template<typename T>
void printVector(const std::string& message, const std::vector<T>& vec) {
    std::cout << message;
    for (const T& val : vec) {
        std::cout << val << " ";
    }
    std::cout << std::endl;
}

int main() {
    std::vector<int> numbers = {5, 2, 8, 1, 9, 4, 6, 3, 7, 0};
    printVector("Original numbers: ", numbers);

    // 1. std::sort
    std::sort(numbers.begin(), numbers.end());
    printVector("Sorted numbers (ascending): ", numbers);

    // Sort in descending order using a lambda expression
    std::sort(numbers.begin(), numbers.end(), [](int a, int b) {
        return a > b;
    });
    printVector("Sorted numbers (descending): ", numbers);

    // 2. std::find
    int value_to_find = 4;
    auto it_find = std::find(numbers.begin(), numbers.end(), value_to_find);
    if (it_find != numbers.end()) {
        std::cout << "Value " << value_to_find << " found at index: " << std::distance(numbers.begin(), it_find) << std::endl;
    } else {
        std::cout << "Value " << value_to_find << " not found." << std::endl;
    }

    // 3. std::count
    int value_to_count = 8; // Let's re-sort to have a predictable count example if needed
    std::sort(numbers.begin(), numbers.end()); // Sort again for consistency in next examples
    numbers.push_back(8); // Add another 8
    printVector("Numbers with an extra 8: ", numbers);
    int count = std::count(numbers.begin(), numbers.end(), value_to_count);
    std::cout << "The value " << value_to_count << " appears " << count << " times." << std::endl;

    // 4. std::accumulate (sum of elements)
    long long sum = std::accumulate(numbers.begin(), numbers.end(), 0LL); // 0LL for long long sum
    std::cout << "Sum of elements: " << sum << std::endl;

    // 5. std::for_each (apply a function to each element)
    std::cout << "Numbers doubled: ";
    std::for_each(numbers.begin(), numbers.end(), [](int& n){ n *= 2; });
    printVector("", numbers);

    // 6. std::transform (create a new sequence from an existing one)
    std::vector<int> squared_numbers;
    squared_numbers.resize(numbers.size()); // Ensure target vector has enough space
    std::transform(numbers.begin(), numbers.end(), squared_numbers.begin(), [](int n) {
        return n * n;
    });
    printVector("Squared numbers: ", squared_numbers);

    // 7. std::iota (fill with a sequence of increasing values)
    std::vector<int> sequence(10);
    std::iota(sequence.begin(), sequence.end(), 100); // Fills with 100, 101, 102, ...
    printVector("Sequence generated by iota: ", sequence);

    // 8. std::remove and erase-remove idiom (to actually remove elements)
    printVector("Numbers before removing 8s: ", numbers);
    // std::remove moves elements to be removed to the end and returns an iterator to the new logical end.
    auto new_end = std::remove(numbers.begin(), numbers.end(), 16); // We doubled 8s to 16s earlier
    // Erase the elements from the new logical end to the actual end of the vector.
    numbers.erase(new_end, numbers.end());
    printVector("Numbers after removing 16s: ", numbers);

    return 0;
}
